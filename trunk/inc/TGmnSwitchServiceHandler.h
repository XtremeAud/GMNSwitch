// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#ifndef __GMN_SWITCH_SERVICE_HANDLER_H__
#define __GMN_SWITCH_SERVICE_HANDLER_H__

#include "TGmnClientService.h"
#include "../inc/GmnClient_constants.h"
#include "../inc/GmnClient_types.h"

#include "TGmnSwitchService.h"
#include "../inc/GmnSwitch_types.h"

#include "ThriftAdapt.h"

#include <thrift/transport/TSocket.h>
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/transport/TBufferTransports.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>

#include <iostream>
#include <string>
#include <vector>
#include <stdint.h>

#define TTL_VALUE 2;    //Global TTL Value

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;
using namespace std;

using namespace  ::gmnswitch;
using namespace  ::gmnclient;

//ThriftAdapt<TGmnClientServiceClient> lsAdapt;



//Struct for Packet
typedef struct
{

    uint32_t uiTTL;
    string strSrc;
    string strDes;
    
}stPacket;


//The packet in progress
class TempTPacket
{
public:

    string SrcName;
    string DesName;
    string Payload;

    int TTL;        //Time to live.  Reduce one when a 'goto' process executed

    TempTPacket(TPacket tPacket)
    {
        SrcName = tPacket.SrcName;
        DesName = tPacket.DesName;
        Payload = tPacket.Payload;
    }
};

class TGmnSwitchServiceHandler : virtual public TGmnSwitchServiceIf
{

private:

    
    //The storage for ALL NAMESPACE SETTING
    vector<TNamespace> NamespaceList;

public:
    //Forward packet
    int ForwardThisPacket(TempTPacket& tPacket, string target)
    {
        TClientPacket p_send;
        p_send.__set_DesName(tPacket.DesName);
        p_send.__set_SrcName(tPacket.SrcName);
        p_send.__set_Payload(tPacket.Payload);

        std::cout << "> FORWARDING PACKET TO: " <<target<<endl;

        boost::shared_ptr<TSocket> socket(new TSocket(target, 9080));
        boost::shared_ptr<TTransport> transport(new TBufferedTransport(socket));
        boost::shared_ptr<TProtocol> protocol(new TBinaryProtocol(transport));
        TGmnClientServiceClient client(protocol);
        transport->open();
        client.Send(p_send);
        transport->close();
        cout << "> SENDED" << endl;

        return 0;
    }

    //valueÊÇÓÃÀ´±£´æ·µ»ØÖµµÄ(Ö÷ÒªÊÇÖ¸Ìø×ªµÄNamespaceÃû×Ö), policyÊÇ´«ÈëµÄ¸ÃnamespaceµÄpolicy
    int JSresolution_Namespace(TempTPacket& tPacket, string& value, string policy)
    {
        return 1;
    }

    int JSresolution_Entity(TempTPacket& tPacket, string& name, string& value, string& state, string policy, string& extra_value)
    {
        if(policy == "GOTO AliceDeviceList" && tPacket.DesName == "Alice")
        {
            cout<<"##### RESOLUTION: GOTO AliceDeviceList"<<endl;
            extra_value = "AliceDeviceList";
            return 2;
        }

        else if(policy == "GOTO BobDeviceList" && tPacket.DesName == "Bob")
        {
            cout<<"##### RESOLUTION: GOTO BobDeviceList"<<endl;
            extra_value = "BobDeviceList";
            return 2;
        }


        if(tPacket.DesName.substr(0, 3) != name.substr(0, 3))
        {
            return 0;
        }

        else if(policy == "SEND")
        {
            if(state == "ONLINE")
            {
                cout<<"##### RESOLUTION: SEND"<<endl;
                return 1;
            }
            else
            {
                cout<<"##### RESOLUTION: SEND BUT OFFLINE"<<endl;
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    TGmnSwitchServiceHandler() 
    {
        // Your initialization goes here

          //Initial Namespace List
          cout << "Hello World" << endl;
          cout << "Loading the debug setting..." << endl;

          //Data for testing
          TEntity tE_0, tE_1, tE_2, tE_3, tE_4;
          tE_0.__set_State("ONLINE");
          tE_0.__set_Value("192.168.0.181");
          tE_0.__set_Name("BobPC");
          tE_0.Action.push_back("SEND");
         
          tE_1.__set_State("OFFLINE");
          tE_1.__set_Value("192.168.0.180");
          tE_1.__set_Name("AlicePC");
          tE_1.Action.push_back("SEND");

          tE_2.__set_State("OFFLINE");
          tE_2.__set_Value("192.168.0.179");
          tE_2.__set_Name("AliceTablet");
          tE_2.Action.push_back("SEND");

          tE_3.__set_State("ONLINE");
          tE_3.__set_Value("Alice");
          tE_3.__set_Name("Alice");
          tE_3.Action.push_back("GOTO AliceDeviceList");

          tE_4.__set_State("ONLINE");
          tE_4.__set_Value("Bob");
          tE_4.__set_Name("Bob");
          tE_4.Action.push_back("GOTO BobDeviceList");

          TNamespace tN_0,tN_1,tN_2;
          tN_0.__set_Name("IM-SPACE");
          tN_0.__set_Tag("IM");
          tN_0.Policy.push_back("IF DES = * THEN PASS");
          tN_0.Entity.push_back(tE_3);
          tN_0.Entity.push_back(tE_4);
          NamespaceList.push_back(tN_0);

          tN_1.__set_Name("AliceDeviceList");
          tN_1.__set_Tag("Device");
          tN_1.Policy.push_back("IF DES = * THEN PASS");
          tN_1.Entity.push_back(tE_1);
          tN_1.Entity.push_back(tE_2);
          NamespaceList.push_back(tN_1);

          tN_2.__set_Name("BobDeviceList");
          tN_2.__set_Tag("Device");
          tN_2.Policy.push_back("IF DES = * THEN PASS");
          tN_2.Entity.push_back(tE_0);
          NamespaceList.push_back(tN_2);


          cout << "Done !" << endl<<endl;

          cout << "NAMESPACE SETTING VIEW" << endl;
          for (int indexofNS = 0; indexofNS < NamespaceList.size(); indexofNS++)
          {
              cout << "=======================================================================================" << endl;
              cout << "Namespace Name:" <<
                  NamespaceList[indexofNS].Name <<
                  "    Tag:" << NamespaceList[indexofNS].Tag <<
                  endl<<"Policy:"<<NamespaceList[indexofNS].Policy[0] <<
                  endl << "Entity List:" << endl;
              for (int indexofE = 0; indexofE < NamespaceList[indexofNS].Entity.size(); indexofE++)
              {
                  cout << "No.:" << indexofE;
                  cout << "    Entity Name:" << NamespaceList[indexofNS].Entity[indexofE].Name;
                  cout <<"    Value:" << NamespaceList[indexofNS].Entity[indexofE].Value;
                  cout << "    State:" << NamespaceList[indexofNS].Entity[indexofE].State;
                  cout<<"    Action:" << NamespaceList[indexofNS].Entity[indexofE].Action[0] << endl;
              }
              cout << "=======================================================================================" << endl;
            }
        }


    int QueryThisEntity(TempTPacket tPacket, int indexofTEntity, int indexofTNamespace)
    {
        cout<<"Entity:"<<NamespaceList[indexofTNamespace].Entity[indexofTEntity].Name<<endl;

        //if TTL <=0 then skip this packet

        if (unlikely(tPacket.TTL <= 0))
        {
            return 0;
        }

        string temp_name;
        string temp_value;    //the name of the target namespace
        string temp_state;
        string temp_action;
        string extra_value;
        temp_name = NamespaceList[indexofTNamespace].Entity[indexofTEntity].Name;
        temp_value = NamespaceList[indexofTNamespace].Entity[indexofTEntity].Value;
        temp_state = NamespaceList[indexofTNamespace].Entity[indexofTEntity].State;
        temp_action = NamespaceList[indexofTNamespace].Entity[indexofTEntity].Action[0];


        int result_flag(0);

        //resolute the policy£¡
        result_flag = JSresolution_Entity(tPacket, temp_name, temp_value, temp_state, temp_action, extra_value);

        // 0 ²»match,skip  1 ·¢³ö 2 Ìø×ª
        
        if (result_flag == 0)
        {
            return 0;
        }
        else if (result_flag == 1)
        {
            ForwardThisPacket(tPacket, temp_value);
            return 0;
        }
        else if (result_flag == 2)
        {
            tPacket.TTL -= 1;    //reduce TTL when 'goto' action executed
                                 ////find the index of the target namespace in the list by the particular name of namespace    
            cout<<"> PACKET RESOLUTION >> GOTO NAMESPACE: "<<extra_value<<endl;
            for (int n = 0; n < NamespaceList.size(); n++)
            {
                if (NamespaceList[n].Name == extra_value)
                {
                    QueryThisNamespace(tPacket, n);
                    //break;
                    return 0;
                }
            }
        }

        return 0;
    }

    //Check the namespace
    int QueryThisNamespace(TempTPacket tPacket, int indexofTNamespace)
    {
        cout<<"> NOW SEARCHING IN NS:"<<NamespaceList[indexofTNamespace].Name<<endl;
        // //if TTL <=0 then skip this namespace
        // if (unlikely(tPacket.TTL <= 0))
        // {
        //     //cout << "50" << endl;
        //     return 0;
        // }

        // else
        // {
        //     //cout << "51" << endl;
        //     string temp_value;    //the name of the target namespace
        //     int result_flag(0);
        //     //resolute the policy
        //     //result_flag = JSresolution_Namespace(tPacket, temp_value, NamespaceList[indexofTNamespace].Policy[0]);
        //     result_flag = 1;

        //     if (result_flag == 0)
        //     {
        //         return 0;
        //     }

        //     else if (result_flag == 2)
        //     {
        //         tPacket.TTL -= 1;    //reduce TTL when 'goto' action executed
        //                              //find the index of the target namespace in the list by the particular name of namespace
        //         for (int n = 0; n < NamespaceList.size(); n++)
        //         {
        //             if (NamespaceList[n].Name == temp_value)
        //             {
        //                 QueryThisNamespace(tPacket, n);
        //                 break;
        //             }
        //             return 0;
        //         }
        //     }

            // else if (result_flag == 1)
            // {
                for (int n = 0; n < NamespaceList[indexofTNamespace].Entity.size(); n++)
                {
                    //cout << "E" <<n<< endl;
                    QueryThisEntity(tPacket, n, indexofTNamespace);
                }
                return 1;
        //     }
        // }
        // return 0;
    }

//Actually this function is the 
    void Send(const TPacket& tPacket)
    {
        cout << ">>>>>>>>>>>>>>>>>>>> PACKET IS RECEIVING..." << "  |  srcName=" << tPacket.SrcName << "  desName=" << tPacket.DesName << endl;
      
      //Copy the original packet to a temppacket structure
          TempTPacket tempPacket(tPacket);
      //cout << "1" << endl;
      //Process packet
          for (int n = 0; n < NamespaceList.size(); n++)
          {
         // cout << "2" << endl;
              cout << "> START TO PROCESS PACKET..." << endl;
            QueryThisNamespace(tempPacket, n);
            cout <<"######################################################"<<endl;
        }
        cout<<"<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<"<<endl;



    }

  /**
   * Add TNamespace
   * 
   * @param tNamespace
   */
    void AddNamespace(const TNamespace& tNamespace)
      {
    //Firstly, check if the name of namespace is existed
      uint32_t flag = 0;
      for (int n = 0; n < NamespaceList.size(); n++)
      {
          if (unlikely(NamespaceList[n].Name == tNamespace.Name))
          {
              flag = 1;
              cout << "> NAMESPACE EXISTED" << endl;
              break;
          }
          else
          {
              ;
          }
      }
      if (flag == 0)
      {
          //push this item to the list
          NamespaceList.push_back(tNamespace);
      }
      cout <<" > NAMESPACE SETTING UPDATED" << endl;
      ListNamespace();
    }

  /**
   * Update TNamespace
   * 
   * @param tNamespace
   */
    void UpdateNamespace(const vector<TNamespace> & updated_Namespaces)
    {
        //copy the updated setting to cover that on the switch
        NamespaceList = updated_Namespaces;
        cout << "> NAMESPACE SETTING UPDATED" << endl;
        ListNamespace();
    }
  /**
   * Get a list of TNamespace
   */

    void ListNamespace(std::vector<TNamespace> & _return) 
    {
        //copy data from the local namespace list to the remote one
        _return = NamespaceList;
        cout <<"> CLIENT REQUESTS THE NAMESPACE LSIT"<< endl<<endl;
    }

    //List all namespace and entities on console
    void ListNamespace()
    {
        cout << "NAMESPACE SETTING VIEW" << endl;
        for (int indexofNS = 0; indexofNS < NamespaceList.size(); indexofNS++)
        {
            cout << "=======================================================================================" << endl;
            cout << "Namespace Name:" <<
                NamespaceList[indexofNS].Name <<
                "    Tag:" << NamespaceList[indexofNS].Tag <<
                endl << "Policy:" << NamespaceList[indexofNS].Policy[0] <<
                endl << "Entity List:" << endl;
            for (int indexofE = 0; indexofE < NamespaceList[indexofNS].Entity.size(); indexofE++)
            {
                cout << "No.:" << indexofE;
                cout << "    Entity Name:" << NamespaceList[indexofNS].Entity[indexofE].Name;
                cout << "    Value:" << NamespaceList[indexofNS].Entity[indexofE].Value;
                cout << "    State:" << NamespaceList[indexofNS].Entity[indexofE].State;
                cout << "    Action:" << NamespaceList[indexofNS].Entity[indexofE].Action[0] << endl;
            }
            cout << "=======================================================================================" << endl;
        }
    }
};

#endif
